---
title: "Final Project - GIS"
author: "Thomas Beier, Florian Franz, Konstantin Seeger"
date: "09.02.2022"
output: pdf_document
---

## Spatial prediction of forest microclimate using LiDAR data

Using the `lidr` package by J.-R. Roussel for processing LiDAR data and creating a forest microclimate model.

For information see the book (https://r-lidar.github.io/lidRbook/index.html), the package documentation (https://cran.r-project.org/web/packages/lidR/index.html) and also this publication (https://www.sciencedirect.com/science/article/pii/S0034425720304314).



```{r, results='hide', warning=FALSE, message=FALSE, echo=FALSE}
### Set up a working environment

require(envimaR)

packagesToLoad = c("mapview", "raster", "sf", "caret", "exactextractr",  
                   "doParallel", "CAST", "ranger","rasterVis","dplyr",
                   "lidR", "RColorBrewer")

# Define a project rootfolder
# This is the mandantory rootfolder of the whole project, "E:/" has to be changed to the respective directory where the edu folder is located 
rootDir = "E:/edu/GIS_Project_Beier_Franz_Seeger"  

projectDirList   = c("data/", # data folder
                     "data/raw/",
                     "data/processed/", # folder for processed data (.rds)
                     "data/modelling/",
                     "data/modelling/model_training_data/",
                     "data/modelling/models/",
                     "data/modelling/prediction/",
                     "data/modelling/validation/",
                     "docs/",
                     "tmp/",
                     "src/",
                     "src/functions/")

# Now set automatically root direcory, folder structure and load libraries
envrmt = envimaR::createEnvi(root_folder = rootDir,
                             folders = projectDirList,
                             path_prefix = "path_",
                             libs = packagesToLoad,
                             alt_env_id = "COMPUTERNAME",
                             alt_env_value = "PCRZP",
                             alt_env_root_folder = "F:/BEN/edu")
## set raster temp path
raster::rasterOptions(tmpdir = envrmt$path_tmp)
```

### Read las file

```{r, warning=FALSE, message=FALSE}
# The las file must be in the folder data/raw!!!
las_files <- list.files(envrmt$path_raw,
                       pattern = glob2rx("*.las"),
                       full.names = TRUE)

las <- readLAS(las_files[1])

# Assign a coord. ref. syst. (CRS)
# In this case UTM zone 32N
epsg_number <- 25832
crs(las) <- epsg_number

las

# Check las file
las_check(las)
```

```{r}
### Some plotting...

# Basic 3D plot
#plot(las)

# Example cross section 2D plot (along a transect)
p1 <- c(477500, 5632500) # these are coordinates
p2 <- c(478217.5, 5632500 ) # these are coordinates
las_tr <- clip_transect(las, p1, p2, width = 4, xz = TRUE)

ggplot(las_tr@data, aes(X,Z, color = Z)) + 
  geom_point(size = 0.5) + 
  coord_equal() + 
  theme_minimal() +
  scale_color_gradientn(colours = height.colors(25))
```

### Predictor set

List of variables used for forest microclimate prediction:

- Canopy height (CHM)
- Standard metrics (mean, max, sd...)
- Mean height of first returns
- Maxiumum height of first returns
- Standard deviation of first returns
- Point density
- Pulse density
- Leaf area index (LAI)
- Elevation (DTM)
- Slope
- Exposition
- Topographic position index (TPI)
- Irradiance

All of the predictors are calculated at the grid level within 1 m  x 1 m pixels.

#### Canopy height model (CHM)

```{r, warning=FALSE, message=FALSE}
# Height normalization within the point cloud using invert distance weighting
norm_las <- normalize_height(las, knnidw())

# Check if all ground points are 0
hist(filter_ground(norm_las)$Z, 
     breaks = seq(-0.45, 0.45, 0.01),
     main = "", xlab = "Elevation")

# Calculate CHM using pit-free algorithm (we can discuss about this --> which algorithm we want to use)
chm <- grid_canopy(norm_las, res = 1.0, 
                   pitfree(thresholds = c(0, 2, 5, 10, 15),
                           max_edge = c(0, 1.5)))

chm # min value of -0.003 and max value of 42.168...maybe false
```

```{r, echo=FALSE}
# tmap plot
library(tmap)
tm_shape(chm) +
tm_raster(title = "Pitfree CHM 1 m² cells", palette = height.colors(20)) +
  tm_grid() +
  tm_layout(legend.outside = TRUE)
```

#### Standard metrics of the canopy

```{r}
chm_stdmetrics <- grid_metrics(norm_las, .stdmetrics, res = 1.0)
plot(chm_stdmetrics, col = height.colors(20))
```

#### First returns mean height, maxiumum height and standard deviation of the height from the first returns

```{r}
# Function for calculating mean, max and standard deviation of first returns
first_return_metrics <- function(x) {
  list(mean = mean(x),
       max = max(x), 
       sd(x))
}

return_mean_max_sd <- grid_metrics(norm_las, func = ~first_return_metrics(Z),
                                   res = 1.0, filter = ~ReturnNumber == 1L)
```

```{r, echo=FALSE, warning=FALSE, fig.width=12, fig.height=7}
par_org <- par()
par(mfrow = c(2,3), cex.main = 1)

hist(return_mean_max_sd[[1]],
     main = "Histogram of first returns mean height",
     xlab = "Height [m]")

hist(return_mean_max_sd[[2]],
     main = "Histogram of first returns maximum height",
     xlab = "Height [m]")

hist(return_mean_max_sd[[3]],
     main = "Histogram of first returns height standard deviation",
     xlab = "Height [m]")

raster::plot(return_mean_max_sd[[1]],
             col = height.colors(20),
             main = "First returns mean height 1 m² cells")

raster::plot(return_mean_max_sd[[2]],
             col = height.colors(20),
             main = "First returns maximum height 1 m² cells")

col_pal <- colorRampPalette(c("forestgreen","green","yellow","red","purple4"))
raster::plot(return_mean_max_sd[[3]],
             col =  col_pal(10),
             main = "First returns height standard deviation 1 m² cells")

par(par_org)
```

#### Point and pulse density

```{r}
point_density <- grid_metrics(norm_las, ~length(Z)/1, res = 1.0)
pulse_density <- grid_metrics(norm_las, ~length(Z)/1, res = 1.0,
                              filter = ~ReturnNumber == 1L)
```

```{r, echo=FALSE, warning=FALSE, fig.width=10, fig.height=7}
par(mfrow = c(2,2), cex.main = 1)

hist(point_density,
     main = "Histogram of point density",
     xlab = "Number of points")

hist(pulse_density,
     main = "Histogram of pulse density",
     xlab = "Number of points")

raster::plot(point_density, 
             col = gray.colors(50,0,1),
             main = "Point density 1 m² cells")

raster::plot(pulse_density, 
             col = gray.colors(50,0,1),
             main = "Pulse density 1 m² cells")

par(par_org)
```

#### Leaf area index (LAI)

```{r}
# Calculate Leaf area index with the "canopyLazR" package. Installation can be found on the following github page: https://github.com/akamoske/canopyLazR
# Convert .laz or .las file into a voxelized lidar array
laz.data <- laz.to.array(laz.file.path = file.path(envrmt$path_raw,"las_mof.las"), 
                         voxel.resolution = 10, 
                         z.resolution = 1,
                         use.classified.returns = TRUE)

# Level the voxelized array to mimic a canopy height model
level.canopy <- canopy.height.levelr(lidar.array = laz.data)

# Estimate Leaf Area Density (LAD) for each voxel in leveled array
lad.estimates <- machorn.lad(leveld.lidar.array = level.canopy, 
                             voxel.height = 1, 
                             beer.lambert.constant = NULL)

# Convert the LAD array into a single raster stack
lad.raster <- lad.array.to.raster.stack(lad.array = lad.estimates, 
                                        laz.array = laz.data, 
                                        epsg.code = 25832) # The epsg code maybe needs to be changed. 


# Create a single LAI raster from the LAD raster stack
lai.raster <- raster::calc(lad.raster, fun = sum, na.rm = TRUE)

plot(lai.raster)
```


#### Elevation

```{r, warning=FALSE}
# Calculate DTM using invert distance weighting
dtm <- grid_terrain(las, res = 1.0, algorithm = knnidw(k = 6L, p = 2))
```

```{r, echo=FALSE, warning=FALSE, fig.width=10, fig.height=5}
par(mfrow = c(1,2), cex.main = 1)

hist(dtm,
     breaks = 20,
     main = "Histogram of the elevation",
     xlab = "Elevation [m]")

lidR::plot(dtm,
           col = height.colors(50),
           main = "Invert distance weighting DTM 1 m² cells")

par(par_org)
```

#### Slope, exposition and TPI

```{r}
slope <- raster::terrain(dtm, opt = "slope", unit = "degrees", neighbors = 8)
exposition <- raster::terrain(dtm, opt = "aspect", unit = "degrees", neighbors = 8)
tpi <- raster::terrain(dtm, opt = "tpi")
```

```{r, echo=FALSE, warning=FALSE, fig.width=10, fig.height=7}
par(mfrow = c(2,3), cex.main = 1)

hist(slope,
     main = "Histogram of slope",
     xlab = "Slope [°]")

hist(exposition,
     main = "Histogram of exposition",
     xlab = "Exposition [°]")

hist(tpi,
     main = "Histogram of tpi")

raster::plot(slope,
             col = topo.colors(25),
             main = "Slope in degrees")

raster::plot(exposition,
             col = bpy.colors(25),
             main = "Exposition in degrees")

raster::plot(tpi,
             col = topo.colors(25),
             main = "TPI")

par(par_org)
```

#### Irradiance






























